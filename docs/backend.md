# Backend Architecture

This document provides a detailed explanation of the backend services, data models, and security rules that power the REON AI PREP application.

## 1. Firebase as a Backend-as-a-Service (BaaS)

The application leverages **[Firebase](https://firebase.google.com/)** as its primary backend platform. This choice allows for rapid development, real-time data synchronization, and a secure, scalable infrastructure without the need to manage a traditional server.

### 1.1. Firebase Authentication

**Purpose**: To provide secure and easy-to-implement user authentication.

**Key Features**:
- **Multi-Provider Support**: The app supports both **Email/Password** and **Google Sign-In**, offering flexibility for users. This is configured in `docs/backend.json` under the `auth.providers` key.
- **Session Management**: Firebase automatically handles user sessions, token refreshes, and secure credential management, which simplifies the development process.
- **User Ownership Model**: The `uid` generated by Firebase Auth for each user is the cornerstone of the app's security model. It acts as the primary key for user-specific data in Firestore, ensuring that users can only access their own information.

**Working Logic & Strategy**:
- When a new user registers (either via email or Google), a unique `uid` is created.
- This `uid` is then used to create a corresponding user document in the `/users/{userId}` collection in Firestore.
- All subsequent data created by that user (e.g., quiz results, practice tests, notes) is stored in subcollections under their specific user document (`/users/{userId}/quizzes/{quizId}`).
- Firestore Security Rules (covered below) use this `uid` to enforce a strict user-ownership policy, preventing any user from reading or writing another user's data.

### 1.2. Firestore (Database)

**Purpose**: To store all application data in a scalable, real-time, NoSQL cloud database.

#### Data Modeling Strategy (`docs/backend.json`)

The entire database schema is formally defined in the `docs/backend.json` file. This file serves as the single source of truth for all data entities and their relationships.

- **Entities**: This section defines the JSON schema for each data model (e.g., `User`, `Quiz`, `MockTest`). This ensures data consistency and provides a clear blueprint for what each document should contain.
- **Firestore Structure**: This section maps the abstract entities to concrete Firestore collection paths. The core strategy here is **path-based security and data isolation**.

**Key Principles of the Data Structure**:
1.  **User-Owned Data**: All data that is personal to a user is stored in subcollections under that user's document (e.g., `/users/{userId}/profiles/{profileId}`). This structure is fundamental to the security model.
2.  **Global Data**: Data that is public or shared (like `leaderboardEntries`) is stored in top-level collections. Access to this data is controlled differently in the security rules.
3.  **Denormalization for Security**: The security rules are designed to be fast and cost-effective by avoiding `get()` or `exists()` calls to other documents. To achieve this, authorization-critical data (like `userId`) is denormalized and stored directly on the documents themselves. For example, a `quiz` document under `/users/{userId}/quizzes/{quizId}` will also contain a `userId` field. This allows a security rule to validate ownership by only looking at the document being requested.

#### Firestore Security Rules (`firestore.rules`)

**Purpose**: To protect user data from unauthorized access.

The `firestore.rules` file implements the security strategy defined by the data model.

**Core Logic**:
- **Default Deny**: By default, all paths in the database are locked down. Access must be explicitly granted.
- **Path-Based Ownership**: The rules heavily rely on matching the `request.auth.uid` (the authenticated user's ID) with the `{userId}` wildcard in the document path.
  - A typical rule looks like this: `allow read, write: if isOwner(userId);`, where `isOwner(userId)` is a helper function that checks `request.auth.uid == userId`.
- **Preventing Data Leakage**: The rules explicitly disallow listing documents in the top-level `/users` collection (`allow list: if false;`). This prevents a malicious actor from being able to enumerate all users of the application.
- **Validation on Write**: For `create` and `update` operations, the rules validate the incoming data to ensure its integrity. For example, a new quiz document must have a `userId` field that matches the `userId` in the path. Immutable fields (like `id` and `userId`) are also protected from being changed on update.
- **Restricted Writes for Global Data**: For public collections like `/leaderboardEntries`, client-side writes are disabled (`allow write: if false;`). This is a critical security measure to prevent cheating. Such data should only be updated by a trusted server-side environment (e.g., a Cloud Function) that can perform its own validation.

## 2. Generative AI

The application's intelligent features are powered by a combination of AI models accessed through different services.

### 2.1. LIBRA AI Assistant (OpenRouter + Mistral)

**Purpose**: To provide an interactive chatbot for doubt-solving, content generation, and study advice.

**Working Logic**:
- The LIBRA AI assistant is implemented in `src/components/libra/LibraSidebar.tsx`.
- It makes direct, client-side API calls to the **[OpenRouter](https://openrouter.ai/)** service, which acts as a gateway to various large language models.
- The model used is **Mistral** (`mistralai/mistral-7b-instruct`), which is a powerful and cost-effective model suitable for conversational AI.
- **System Prompt**: A detailed system prompt is sent with every API request. This prompt instructs the AI on its persona ("LIBRA, a professional educational assistant"), its required tone, the expected response structure (using Markdown), and its areas of expertise. This is crucial for ensuring consistent and high-quality responses.
- **Streaming Responses**: The integration uses the `stream: true` parameter to receive the AI's response as a real-time stream of text. This provides a much better user experience, as the user sees the response being generated token-by-token, rather than waiting for the full response to be ready.

### 2.2. AI-Generated Podcasts (Google AI)

**Purpose**: To convert text-based study materials into audible podcasts.

**Working Logic**:
- This feature uses a server-side **Genkit Flow** defined in `src/ai/flows/generate-podcast-from-text.ts`.
- The flow takes a string of text as input.
- It then calls a **Google AI** Text-to-Speech model to convert this text into an audio file.
- The resulting audio is returned to the client as a Base64-encoded data URI, which can be played directly in the browser using the `<audio>` HTML tag.
- By handling this in a Genkit flow, the API keys and specific model details are kept on the server, which is more secure and allows for easier management.
